
# BINARY EXPLOITATION

## Basics
---

### Rules

1. Always check for the file format — whether it's a 32-bit ELF or a 64-bit.
2. Always check if the file is dynamically linked or statically linked.
3. Always check if the file is stripped or not.
4. Always check for file security protections.
5. Always search for strings in Radare2 — this will also show addresses.

> 💡 **Note to self:**  
To remove security protections in an already compiled file, you can use the following command (there’s no harm in trying):

```bash
gcc (file) -o vuln -fno-stack-protector -z execstack -no-pie -m32   # or -m64
```

---

## Buffer Overflow
A buffer overflow leaves a system vulnerable, allowing exploitation by injecting specifically tailored code.

- This code can overwrite memory regions and potentially allow arbitrary code execution.
- Buffer overflows are common in network security — if the overflow is well-adjusted, an attacker can run other programs or gain administrative access.

### Common `pwndbg` Commands

- `info functions` — Show all functions in the binary.
- `disassemble main` — Show assembly of the main function.
- `info stack` — Show stack information for the current context.
- `x` — Examine memory/registers.

```bash
x $eax         # input
0xffff47824: 0xecui24  # output
```

- `p` — Print values (can show registers as decimals):

```bash
p $eax
```

- `delete breakpoints` — Remove breakpoints from the debugging session.

---

## Topic 2: Overwriting Stack Variables (Local Stack)

### New Tool: `ltrace`
`ltrace` is used to trace library calls and their return values. It’s useful when the source code is not available.

#### Why Use `ltrace`:
- Reveal program behavior and internal logic.
- Catch hidden flags and hardcoded passwords using `strcmp()` or `puts()`.
- Bypass input validation by observing string comparisons.
- Understand obfuscation/encryption logic using calls like `strcat()`, `memcpy()`, `fopen()`.

If there is a `cmp` instruction comparing strings (e.g., `[ebp - 0xc]`), you can:

- Find the address it jumps to (e.g., `main+169`).
- Check the value:

```bash
x $ebp-0xc
```

- Set the value manually (the address may hold a pointer, not a literal value):

```bash
set {int}0xffffdadw = 1
```

> ⚠️ This technique can help retrieve data stored locally in the binary. However, it may not work on remote servers — but it's always worth trying.

---

## Topic 3: Return To Win

This is one of the most beginner-friendly binary exploitation challenges.

- Typically involves calling a `void` function or hidden `flag()` function.
- **Offset**: The number of bytes needed to overflow the buffer and overwrite the instruction pointer (RIP on x86_64 or EIP on x86).
- The goal is to fill the buffer (e.g., `"A" * offset`) and overwrite the pointer with a controlled value (like the address of `flag()`).

### Finding Offsets Manually (if `pwndbg` fails):

```python
from pwn import *

pattern = cyclic(100)
print(pattern)  # Send this to the binary

# After crash:
print(cyclic_find(0x616161616c))  # Replace with the crashed value from EIP/RIP
```

Here is a template from pwn-tools for binary exploitation
```
#!/usr/bin/env python3
from pwn import *

# Set context (auto-detect architecture if possible)
context.binary = elf = ELF('./vuln')  # Replace with your binary
context.log_level = 'debug'           # Change to 'info' or 'error' to reduce verbosity
context.terminal = ['tmux', 'splitw', '-h']  # For GDB

# Load libc if needed
# libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')  # Change path if needed

# Choose local or remote
def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.REMOTE:
        return remote('example.com', 1337)  # Replace with actual IP and port
    elif args.GDB:
        return gdb.debug([elf.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([elf.path] + argv, *a, **kw)

# GDB script for debugging
gdbscript = '''
tbreak main
continue
'''.format(**locals())

# ==========================================================
# ===================== EXPLOIT BEGINS =====================
# ==========================================================
io = start()

# Example usage:
# payload = b'A' * offset + p64(system) + ...
# io.sendlineafter(">", payload)

io.interactive()



```